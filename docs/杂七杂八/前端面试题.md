## CSS

### 1、BFC

理解：BFC 是 CSS 布局的一个概念，是一块独立的渲染区域，一个环境，里面的元素不会影响到外部的元素。

:notebook_with_decorative_cover: 如何生成 BFC（脱离文档流）

- 根元素，即 HTML 元素（最大的一个 BFC）
- float 的值不为 none
- position 的值为absolute 或 fixed
- overflow 的值不为 visible（默认值，内容不会被修剪，会呈现在元素框之外）
- display 的值为inline-block、table-cell、table-caption

:notebook_with_decorative_cover: BFC 布局规则

- 内部的 Box 会在垂直方向，一个接一个地放置
- 属于同一个 BFC 的两个相邻的 Box 的 margin 会发生重叠
-  BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此，文字环绕效果，设置 float
- BFC 的区域不会与 float box 重叠

### 2、垂直居中一个元素

- 绝对定位。通过与父元素的绝对定位来让自身实现垂直居中。
- 如果居中的是行内元素，可以设置父级 height 与 line-height 相等
- 设置 margin/padding 居中
- 相对位置偏移居中
- flex 居中。设置 align-items:center 即可

### 3、



## Vue

### 1、在使用计算属性的时候，函数名和 data 数据源中的数据可以同名吗 ?

不可以同名。因为 data、props、methods、computed 最终都会挂载到 vue 实例上，因此各自在初始化的时候都会有属性重名的判断，所以这四者属性名不能重复。

### 2、怎么解决 vue 打包后静态资源图片失效的问题？

### 3、怎么解决 vue 动态设置 img 的 src 不生效的问题？

require('@/assets/images/xxx.png')

### 4、怎么访问到子组件的实例或者子元素？

this.$refs

### 5、在子组件中怎么访问到父组件的实例？

this.$parent

### 6、在组件中怎么访问到根实例？

this.$root

### 7、说说你对 slot 的理解有多少？slot 使用场景有哪些？

slot 即插槽, 在使用组件的时候, 在组建内部插入东西，通过插槽可以让用户可以拓展组件，去更好地复用组件和对其做定制化处理。

比如布局组件、表格列、下拉选、弹框显示内容等。

### 8、vue 在 created 和 mounted 这两个生命周期中请求数据有什么区别呢？



### 9、vue 在开发过程中要同时跟N个不同的后端人员联调接口（请求的 url 不一样）时你该怎么办？

devServer 中把所有的服务人员的地址代理都写进去，然后动态更改接口的 baseUrl ，这样切换不同后端人员的时候不用重启。

### 10、为什么 data 属性必须声明为返回一个初始数据对应的函数呢？

对象为引用类型，当重用组件时，由于数据对象都指向同一个 data 对象，当在一个组件中修改 data 时，其他重用的组件中的 data 会同时被修改；而使用返回对象的函数，由于每次返回的都是一个新对象（ Object 的实例），引用地址不同，则不会出现这个问题。

### 11、v-for 循环中 key 有什么作用？

给每个 dom 元素加上 key 作为唯一标识 ，diff 算法可以正确的识别这个节点，使页面渲染更加迅速。

### 12、vue 中组件的 name 有什么作用？

- 当你用 vue-tools 时 vue-devtools 调试工具里显示的组件名称是由 vue 中组件 name 决定的。

- DOM 做递归组件时，比如说 detail.vue 组件里有个 list.vue 子组件，递归迭代时需要调用自身 name 。

- 当项目使用 keep-alive时，可搭配组件 name 进行缓存过滤，使用了keep-alive导致我们第二次进入的时候页面不会重新请求，即触发 mounted 函数。这里的 Detail 就是该组件的名字 。

### 13、Vue 子组件和父组件生命周期执行顺序？

#### 加载渲染过程：

父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子
beforeMount -> 子 mounted -> 父 mounted

#### 子组件更新过程：

父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated

#### 父组件更新过程：

父 beforeUpdate -> 父 updated

#### 销毁过程：

父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed

### 14、为什么 Vue data 必须是函数？

- 在 Vue 中根实例的 data 可以是对象也可以是函数，但是在组件中的 data 必须要是一个函数，组件就是可以复用的 Vue 实例，把公共的模块抽离出来，达到复用和直接使用的效果。
- 如果 data 是一个对象的话，对象是一个引用类型；它会在堆空间中开辟一片区域，将内存地址存入。这就使得所有的组件公共一个 data，当一个组件中修改了 data 中的数据就会出现一变全变的现象。
- 如果 data 是一个函数的话，且使用 return 返回一个对象；这就使得每复用一次组件就会返回一个全新的 data （这就相当于 scoped，每一个组件 data 都是私有的，互不干扰，各个组件维护自己的 data ）。

### 15、ElementUI 怎么修改组件的默认样式？

```
// ⽅式1、直接按照 element 默认修改主题的⽅式, 直接修改配置；

// ⽅式2、⽤ >>> 穿透，如： .el-table >>> .el-table__header ；

// ⽅式3、直接修改主题 theme；
```

### 16、vue 组件之间的通信都有哪些？

```js
props
$on $emit
$parent、$children、$refs
bus
vuex
provide、inject
$attrs、$listeners
```

### 17、v-show 和 v-if 有什么区别？使用场景分别是什么？

区别：v-if 不渲染 DOM，v-show 会渲染 DOM。
v-show 使用场景：预渲染需求、需要频繁切换显示状态。

### 18、watch 怎么深度监听对象变化？

deep 设置为 true 就可以监听到对象的变化。

```javascript
'obj.xx': { 
 	handler: function(newVal, oldVal) {},
 	deep: true
}
```

### 19、使用 Object.defineProperty 来进行数据劫持有什么缺点？

在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 `Object.defineProperty` 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。

在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用 Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。

### 20、Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？

不会立即同步执行重新渲染。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。

如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环 tick 中，Vue 刷新队列并执行实际（已去重的）工作。

### 21、Vue 的性能优化有哪些？

#### 编码阶段

- 尽量减少 data 中的数据，data 中的数据都会增加 getter 和 setter ，会收集对应的watcher
- v-if 和 v-for 不能连用
- 如果需要使用 v-for 给每项元素绑定事件时使用事件代理
- SPA 页面采用 keep-alive 缓存组件
- 在更多的情况下，使用 v-if 替代 v-show
- key 保证唯一
- 使用路由懒加载、异步组件
- 防抖、节流
- 第三方模块按需导入
- 长列表滚动到可视区域动态加载
- 图片懒加载

#### SEO 优化

- 预渲染
- 服务端渲染 SSR

#### 打包优化

- 压缩代码
- Tree Shaking/Scope Hoisting
- 使用cdn加载第三方模块
- 多线程打包 happypack
- splitChunks 抽离公共文件
- sourceMap 优化

#### 用户体验

- 骨架屏
- PWA
- 还可以使用缓存（客户端缓存、服务端缓存）优化、服务端开启 gzip 压缩等。

### 22、v-if 和 v-for 哪个优先级更高？如果同时出现，应如何优化？

v-for 优先于 v-if 被解析，如果同时出现，每次渲染都会先执行循环再判断条件，无论如何循环都不可避免，浪费了性能。

要避免出现这种情况，则在外层嵌套 template，在这一层进行 v-if 判断，然后在内部进行 v-for 循环。如果条件出现在循环内部，可通过计算属性提前过滤掉那些不需要显示的项。

### 23、keep-alive 中的生命周期哪些？

keep-alive是 Vue 提供的一个内置组件，用来对组件进行缓存——在组件切换过程中将状态保留在内存中，防止重复渲染 DOM 。

如果为一个组件包裹了 keep-alive，那么它会多出两个生命周期：deactivated、activated。同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。

当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期；当组件被切回来时，再去缓存里找这个组件、触发 activated钩子函数。

### 24、路由的 hash 和 history 模式的区别

Vue-Router 有两种模式：hash 模式和 history 模式。默认的路由模式是 hash 模式。

#### hash 模式

简介： hash 模式是开发中默认的模式，它的 URL 带着一个 # ，例如：`http://www.abc.com/#/vue`，它的 hash 值就是 `#/vue`。

特点：hash 值会出现在 URL 里面，但是不会出现在 HTTP 请求中，对后端完全没有影响。所以改变 hash 值，不会重新加载页面。这种模式的浏览器支持度很好，低版本的 IE 浏览器也支持这种模式。hash 路由被称为是前端路由，已经成为 SPA（单页面应用）的标配。

原理： hash 模式的主要原理就是 onhashchange() 事件：

```js
window.onhashchange = function(event){
    console.log(event.oldURL, event.newURL);
    let hash = location.hash.slice(1);
}
```

使用 onhashchange 事件的好处就是，在页面的 hash 值发生变化时，无需向后端发起请求，window 就可以监听事件的改变，并按规则加载相应的代码。除此之外，hash 值变化对应的 URL 都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后端服务器，但是页面的 hash 值和对应的 URL 关联起来了。

#### history 模式

简介： history 模式的 URL 中没有 #，它使用的是传统的路由分发模式，即用户在输入一个 URL 时，服务器会接收这个请求，并解析这个 URL，然后做出相应的逻辑处理。

特点： 当使用 history 模式时，URL就像这样：`http://abc.com/user/id` 。相比 hash 模式更加好看。但是，history 模式需要后台配置支持。如果后台没有正确配置，访问时会返回 404 。

API： history api 可以分为两大部分，切换历史状态和修改历史状态：

- 修改历史状态：包括了 HTML5 History Interface 中新增的 `pushState()` 和 `replaceState()` 方法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了 url，但浏览器不会立即向后端发送请求。如果要做到改变 url 但又不刷新页面的效果，就需要前端用上这两个 API 。

- 切换历史状态： 包括 `forward()`、`back()`、`go()` 三个方法，对应浏览器的前进，后退，跳转操作。

虽然 history 模式丢弃了丑陋的 #。但是，它也有自己的缺点，就是在刷新页面的时候，如果没有相应的路由或资源，就会刷出 404 来。

如果想要切换到 history模式，就要进行以下配置（后端也要进行配置）：

```js
const router = new VueRouter({
  mode: 'history',
  routes: [...]
})
```

#### 两种模式对比

- history 模式的 pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；
- pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；
- pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；
- pushState() 可额外设置 title 属性供后续使用。
- hash 模式下，仅 hash 符号之前的 url 会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回 404 错误；history 模式下，前端的 url 必须和实际向后端发起请求的 url一致，如果没有对用的路由处理，将返回 404 错误。

hash 模式和 history 模式都有各自的优势和缺陷，还是要根据实际情况选择性的使用。

### 25、说说你对虚拟 DOM 的理解？

1、虚拟 dom 顾名思义就是虚拟的 dom 对象，它本身就是一个 JavaScript 对象，只不过它是通过不同的属性去描述一个视图结构。

2、通过引入 vdom 我们可以获得如下好处：

- 将真实元素节点抽象成 VNode，有效减少直接操作 dom 次数，从而提高程序性能
- 直接操作 dom 是有限制的，比如：diff、clone 等操作，一个真实元素上有许多的内容，如果直接对其进行 diff 操作，会去额外 diff 一些没有必要的内容；同样的，如果需要进行 clone 那么需要将其全部内容进行复制，这也是没必要的。但是，如果将这些操作转移到 JavaScript 对象上，那么就会变得简单了。
- 操作 dom 是比较昂贵的操作，频繁的 dom 操作容易引起页面的重绘和回流，但是通过抽象 VNode 进行中间处理，可以有效减少直接操作 dom 的次数，从而减少页面重绘和回流。
- 同一 VNode 节点可以渲染成不同平台上的对应的内容，比如：渲染在浏览器是 dom 元素节点，渲染在 Native（ iOS、Android） 变为对应的控件、可以实现 SSR 、渲染到 WebGL 中等等。
- Vue3 中允许开发者基于 VNode 实现自定义渲染器（renderer），以便于针对不同平台进行渲染。

3、vdom 如何生成？在vue中我们常常会为组件编写模板 - template， 这个模板会被编译器 - compiler 编译为渲染函数，在接下来的挂载（mount）过程中会调用 render 函数，返回的对象就是虚拟 dom 。但它们还不是真正的 dom ，所以会在后续的 patch 过程中进一步转化为 dom 。

4、挂载过程结束后，vue 程序进入更新流程。如果某些响应式数据发生变化，将会引起组件重新 render ，此时就会生成新的 vdom ，和上一次的渲染结果 diff 就能得到变化的地方，从而转换为最小量的 dom 操作，高效更新视图。

### 26、你知道哪些 vue3 新特性？

1、api 层面 Vue3 新特性主要包括：

- Composition API
- SFC
- Composition API语法糖
- Teleport 传送门
- Fragments 片段
- Emits 选项
- 自定义渲染器
- SFC CSS 变量
- Suspense

2、在框架层面的改进

- 虚拟 DOM 重写
- 编译器优化：静态提升、patchFlags、block等
- 基于Proxy的响应式系统
- 更好的摇树优化
- TypeScript + 模块化
- 更容易扩展

### 27、怎么定义动态路由？怎么获取传过来的动态参数？

很多时候，我们需要将给定匹配模式的路由映射到同一个组件，这种情况就需要定义动态路由。

例如，我们可能有一个 User 组件，它应该对所有用户进行渲染，但用户 ID 不同。在 Vue Router 中，我们可以在路径中使用一个动态字段来实现，例如：`{ path: '/users/:id', component: User }`，其中 `:id` 就是路径参数；

路径参数用冒号 `:` 表示。当一个路由被匹配时，它的 params 的值将在每个组件中以 `this.$route.params` 的形式暴露出来；

参数还可以有多个，例如 `/users/:username/posts/:postId `；除了 `$route.params` 之外，`$route` 对象还公开了其他有用的信息，如 `$route.query` 、`$route.hash` 等。

### 28、说说 nextTick 的使用和原理？

nextTick 是等待下一次 DOM 更新刷新的工具方法。

Vue 有个异步更新策略，意思是如果数据变化，Vue 不会立刻更新 DOM ，而是开启一个队列，把组件更新函数保存在队列中，在同一事件循环中发生的所有数据变更会异步的批量更新。这一策略导致我们对数据的修改不会立刻体现在 DOM 上，此时如果想要获取更新后的 DOM 状态，就需要使用 nextTick 。

场景：created 中想要获取 DOM 时，响应式数据变化后获取 DOM 更新后的状态，比如希望获取列表更新后的高度。

在 Vue 内部，nextTick 之所以能够让我们看到DOM更新后的结果，是因为我们传入的 callback 会被添加到队列刷新函数（flushSchedulerQueue）的后面，这样等队列内部的更新函数都执行完毕，所有 DOM 操作也就结束了，callback 自然能够获取到最新的 DOM 值。

### 29、Proxy 与 Object.defineProperty 优劣对比

1、Proxy 的优势如下

- Proxy 可以直接监听对象而非属性
- Proxy 可以直接监听数组的变化
- Proxy 有多达 13 种拦截方法，不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的
- Proxy 返回的是一个新对象，我们可以只操作新的对象达到目的，而Object.defineProperty 只能遍历对象属性直接修改
- Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利

2、Object.defineProperty 的优势如下

- 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题，而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。

## JavaScript

### 1、export 和 export default 有什么区别？

- `export` 是命名导出，每个模块可以命名导出多个
- `export default` 是默认导出，每个模块只能默认导出一个
- 使用 `export default` 导出的使用 `import XX from 'xxx'` 来导入
- 使用 `export` 导出的使用 `import { exportName } from 'xxx'` 来导入
- 两者可以同时存在

### 2、 说下 var、let 和 const 有什么区别？

- var、let 定义变量，const 定义常量
- var 存在变量提升，let 和 const 不存在变量提升
- let、const 有块级作用域（以大括号为边界）
- const 声明的变量，基本类型的数据无法修改，但是数组和对象可以修改内部的属性值
- var 可以重复声明，let、const 在同一个块级作用域中重复声明会报语法错误
- 浏览器的全局对象是 window ，Node 的全局对象是 global 。var 声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是 let 和 const 不会
- 在使用 let、const 命令声明变量之前，该变量都是不可用的。这在语法上，称为暂时性死区。使用 var 声明的变量不存在暂时性死区
- 在变量声明时，var 和 let 可以不用设置初始值。而 const 声明变量必须设置初始值。

### 3、请说说 new String("A") 和 String("A") 分别返回的结果，请解释为什么？

- new String("A")：返回类型是引用类型，在堆内存储，返回值是字符串对象
- String("A”)：返回类型是基本类型，在栈内存储，返回值是字符串值，和直接定义‘A’没区别

### 4、在严格模式下，全局作用域中函数中 this 的值是什么？

全局作用域中函数中的 this 指向 undefined 。

### 5、箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？

- 箭头函数没有 this，它会从自己的作用域链的上一层继承 this（因此无法使用 apply / call / bind 进行绑定 this 值）
- 箭头函数不可以使用 arguments 对象，该对象在函数体内不存在，如果要用，可以用 rest 参数代替
- 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数
- 不可以使用 new 命令，因为没有自己的 this 以及 prototype 属性

### 6、数据类型检测的方式有哪些？

```js
// typeof
console.log(typeof 2);             // number
console.log(typeof true);          // boolean
console.log(typeof 'str');         // string
console.log(typeof []);            // object    
console.log(typeof function(){});  // function
console.log(typeof {});            // object
console.log(typeof undefined);     // undefined
console.log(typeof null);          // object

// instanceof
// 是判断在其原型链中能否找到该类型的原型
// instanceof只能正确判断引用数据类型，而不能判断基本数据类型
console.log(2 instanceof Number);               // false
console.log(true instanceof Boolean);           // false
console.log('str' instanceof String);           // false
console.log([] instanceof Array);               // true
console.log(function(){} instanceof Function);  // true
console.log({} instanceof Object);              // true

// constructor
// constructor有两个作用，一是判断数据的类型，二是对象实例通过 constrcutor 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，constructor 就不能用来判断数据类型了
console.log((2).constructor === Number);                // true
console.log((true).constructor === Boolean);            // true
console.log(('str').constructor === String);            // true
console.log(([]).constructor === Array);                // true
console.log((function() {}).constructor === Function);  // true
console.log(({}).constructor === Object);               // true

// Object.prototype.toString.call()
var a = Object.prototype.toString;

console.log(a.call(2));             // [object Number]
console.log(a.call(true));          // [object Boolean]
console.log(a.call('str'));         // [object String]
console.log(a.call([]));            // [object Array]
console.log(a.call(function(){}));  // [object Function]
console.log(a.call({}));            // [object Object]
console.log(a.call(undefined));     // [object Undefined]
console.log(a.call(null));          // [object Null]

// Array.isArray()
// 判断数组
Array.isArray(obj);
console.log(Array.isArray([]));     // true
console.log(Array.isArray(123));    // false
console.log(Array.isArray(null));   // false
```

### 7、null 和 undefined 区别

首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。 undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。 undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。 当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object” ，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。

### 8、|| 和 && 操作符的返回值？

|| 和 && 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。

- 对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。
- && 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。

|| 和 && 返回它们其中一个操作数的值，而非条件判断的结果

```js
true && console.log(1)   // 1
false && console.log(1)  // false
```

### 9、new 操作符的实现原理。

new 操作符的执行过程：

- 首先创建了一个新的空对象
- 设置原型，将对象的原型设置为函数的 prototype 对象
- 让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）
- 判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。

```js
// 具体实现
function objectFactory() {
  let newObject = null;
  let constructor = Array.prototype.shift.call(arguments);
  let result = null;
  // 判断参数是否是一个函数
  if (typeof constructor !== "function") {
    console.error("type error");
    return;
  }
  // 新建一个空对象，对象的原型为构造函数的 prototype 对象
  newObject = Object.create(constructor.prototype);
  // 将 this 指向新建对象，并执行函数
  result = constructor.apply(newObject, arguments);
  // 判断返回对象
  let flag = result && (typeof result === "object" || typeof result === "function");
  // 判断返回结果
  return flag ? result : newObject;
}
// 使用方法
// objectFactory(构造函数, 初始化参数);
```

### 10、为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?

arguments 是一个对象，它的属性是从 0 开始依次递增的数字，还有 callee 和 length 等属性，与数组相似；但是它却没有数组常见的方法属性，如 forEach，reduce 等，所以叫它们类数组。

```js
// 要遍历类数组，有三个方法
// 1、将数组的方法应用到类数组上，这时候就可以使用call和apply方法
function foo(){
  Array.prototype.forEach.call(arguments, a => console.log(a))
}

// 2、使用Array.from方法将类数组转化成数组
function foo(){
  const arrArgs = Array.from(arguments)
  arrArgs.forEach(a => console.log(a))
}

// 3、使用展开运算符将类数组转化成数组
function foo(){
  const arrArgs = [...arguments]
  arrArgs.forEach(a => console.log(a))
}
```

### 11、如何判断一个对象是不是空对象？

```js
Object.keys(obj).length === 0
```

### 12、null，undefined 的区别？

undefined 的含义是未定义，一般变量声明了但还没有赋值的时候会返回 undefined。

null 表示准备用来保存对象，还没有真正保存对象的值。从逻辑角度看，null 表示一个空对象指针。

### 13、&&、 || 和 !! 运算符分别能做什么

- `&&` 叫逻辑与，在其操作数中找到第一个虚值表达式并返回它，如果没有找到任何虚值表达式，则返回最后一个真值表达式。它采用短路来防止不必要的工作。
- `||` 叫逻辑或，在其操作数中找到第一个真值表达式并返回它。这也使用了短路来防止不必要的工作。在支持 ES6 默认函数参数之前，它用于初始化函数中的默认参数值。
- `!!` 运算符可以将右侧的值强制转换为布尔值，这也是将值转换为布尔值的一种简单方法。

### 13、ajax中 get 和 post 有什么区别?

- get 和 post 都是数据提交的方式。
- get 的数据是通过网址问号后边拼接的字符串进行传递的。
- post 是通过一个 HTTP 包体进行传递数据的。
- get 的传输量是有限制的，post 是没有限制的。
- get 有缓存，post 没有。
- get 只接受 ASCII 字符的参数数据类型，post 没有限制。
- get 请求参数会保留历史记录，post 中参数不会保留。
- get 在浏览器回退时无害，post 会再次提交请求。
- get 的安全性相对没有 post 高。
- 一般用 get 来获取数据，post 一般用来修改数据。

### 14、post一般用于修改服务器上的资源，对所发送的信息没有限制。比如

- 无法使用缓存文件（更新服务器上的文件或数据库）。
- 向服务器发送大量数据（POST 没有数据量限制）。
- 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠。

### 15、一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）

- 查找浏览器缓存
- DNS 解析、查找该域名对应的 IP 地址、重定向（301）、发出第二个GET请求
- 进行 HTTP 协议会话
- 客户端发送报头（请求报头）
- 服务器回馈报头（响应报头）
- html 文档开始下载文档树建立，根据标记请求所需指定MIME类型的文件
- 文件显示
- 浏览器这边做的工作大致分为以下几步：
- 加载：根据请求的 URL 进行域名解析，向服务器发起请求，接收文件（HTML、JS、CSS、图象等）。
- 解析：对加载到的资源（HTML、JS、CSS等）进行语法解析，建议相应的内部数据结构（比如HTML 的 DOM 树，JS的（对象）属性表，CSS 的样式规则等等）

### 16、什么是事件代理

事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，”事件代理“即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是 DOM 元素的事件冒泡。
使用事件代理的好处是：

- 可以提高性能
- 可以大量节省内存占用，减少事件注册，比如在 table 上代理所有 td 的 click 事件就非常棒
- 可以实现当新增子对象时无需再次对其绑定

### 17、0.1+0.2 !== 0.3 ?

面试的时候，问你这个问题，要是回答错误的话，估计面试官对基础很是怀疑！！！

问你这个题目的时候，你可以牵扯出很多问题，比如 JS 如何存储小数的呢？比如聊一聊二进制，比如实际开发中，遇到精度的问题，你是怎么解决的，你有什么好办法。

聊完这个，你可以牵扯出最大安全数，比如 JavaScript 的最大安全整数是多少，超出这个范围的话，怎么解决精度问题呢？

ES规范中新提出的 BigInt 解决了什么问题呢，你又发现了BigInt中哪些坑呢？

如何解决精度问题呢？

答：因为 0.1 的二进制值是个无限循环小数，JavaScript 使用 64 位 `IEEE 754` 标准，只能表示 52 位小数，所以精度丢失，所以 `0.1 + 0.2 !== 0.3`。

解决：

- 在计算前将值转换为整数 再进行计算
- 对结果进行位截取后进行比较

### 18、为什么会有 BigInt 的提案？

JavaScript 中 Number.MAX_SAFE_INTEGER 表示最大安全数字，计算结果是 9007199254740991，即在这个数范围内不会出现精度丢失（小数除外）。但是一旦超过这个范围，js 就会出现计算不准确的情况，这在大数计算的时候不得不依靠一些第三方库进行解决，因此官方提出了 BigInt 来解决此问题。

### 19、== 操作符的强制类型转换规则？

对于 == 来说，如果对比双方的类型不⼀样，就会强制类型转化后再进行比较，进行如下判断流程：

- 首先会判断两者类型是否相同，相同的话就比较两者的大小

- 类型不相同的话，就会进行类型转换

-  会先判断是否在对比 null 和 undefined，是的话就会返回 true

- 判断两者类型是否为 string 和 number，是的话就会将字符串转换为 number

  ```js
  1 == '1'
        ↓
   1 == 1
  ```

- 判断其中一方是否为 boolean，是的话就会把 boolean 转为 number 再进行判断

  ```js
  '1' == true
   ↓
  '1' == 1
   ↓
   1 == 1
  ```

- 判断其中一方是否为 object 且另一方为 string、number 或者 symbol，是的话就会把 object 转为原始类型再进行判断

  ```js
  '1' == { name: 'js' }
   ↓
  '1' == '[object Object]'
  
  // 对普通对象来说，除非自行定义 toString() 方法，否则会调⽤ toString()
  （Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如"[object
  Object]"。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。
  ```

### 20、如何判断一个对象是空对象？

```js
// 使用 JSON 自带的 stringify 方法来判断

if (JSON.stringify(Obj) == "{}") {
  console.log("空对象");
}

// 使用ES6新增的方法 Object.keys() 来判断
if (Object.keys(Obj).length === 0) {
  console.log("空对象");
}
```

### 21、const 对象的属性可以修改吗？

const 保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数 值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。 但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是⼀个指针，const 只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。

### 22、如果 new 一个箭头函数的会怎么样？

箭头函数是 ES6 中的提出来的，它没有 prototype，也没有自己的 this 指向，更不可以使用 arguments 参 数，所以不能 New 一个箭头函数。 new 操作符的实现步骤如下：

- 创建一个对象
- 将构造函数的作用域赋给新对象（也就是将对象的proto属性指向构造函数的 prototype 属性）
- 指向构造函数中的代码，构造函数中的 this 指向该对象（也就是为这个对象添加属性和方法）
- 返回新的对象

所以，上面的第二、三步，箭头函数都是没有办法执行的。

### 23、扩展运算符的作用及使用场景

1、对象扩展运算符 对象的扩展运算符(...)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。

```js
let bar = { a: 1, b: 2 };
let baz = { ...bar };  // { a: 1, b: 2 }
```

扩展运算符内部的同名属性会被覆盖掉

```js
let bar = { a: 1, b: 2 };
let baz = { ...bar, ...{ a: 2, b: 4 } };  // {a: 2, b: 4}
```

2、数组扩展运算符 数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。

```js
console.log(...[1, 2, 3]);
// 1 2 3

console.log(...[1, [2, 3, 4], 5]);
// 1 [2, 3, 4] 5
```

将数组转换为参数序列

```js
function add(x, y) {
  return x + y;
}
const numbers = [1, 2];
add(...numbers);  // 3
```

合并数组

```js
const [first, ...rest] = [1, 2, 3, 4, 5];
first;  // 1
rest;  // [2, 3, 4, 5]
```

如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错

```js
const [...rest, last] = [1, 2, 3, 4, 5];  // 报错
const [first, ...rest, last] = [1, 2, 3, 4, 5];  // 报错
```

将字符串转为真正的数组

```js
[..."hello"]; // [ "h", "e", "l", "l", "o" ]
```

### 24、对 rest 参数的理解？

扩展运算符被用在函数形参上时，它还可以把一个分离的参数序列整合成一个数组，这一点经常用于获取函数的多余参数，或者处理函数参数个数不确定的情况。

```js
function mutiple(...args) {
  console.log(args);  // [1, 2, 3, 4]
  let result = 1;
  for (var val of args) {
    result *= val;
  }
  return result;
}
mutiple(1, 2, 3, 4);  // 24
```

