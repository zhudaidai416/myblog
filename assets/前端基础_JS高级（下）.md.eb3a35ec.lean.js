import{_ as e,o as c,c as r,x as n,a as s,C as l,z as p,Q as o,D as t}from"./chunks/framework.d6bf9272.js";const y="/myblog/images/面向过程编程.png",D="/myblog/images/面向对象编程.png",F="/myblog/images/构造函数封装.png",i="/myblog/images/原型对象.png",A="/myblog/images/constructor属性.png",C="/myblog/images/prototype.png",b="/myblog/images/原型.png",u="/myblog/images/原型链2.png",m="/myblog/images/原型继承1.png",d="/myblog/images/原型继承2.png",h="/myblog/images/原型继承3.png",g="/myblog/images/浅拷贝1.png",f="/myblog/images/浅拷贝2.png",E="/myblog/images/异常处理throw.png",_="/myblog/images/异常处理debugger.png",v="/myblog/images/防抖.png",j="/myblog/images/节流.png",ys=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"前端基础/JS高级（下）.md","lastUpdated":1699899456000}'),q={name:"前端基础/JS高级（下）.md"},w=o("",48),T=n("p",null,"⚠️ 注：",-1),P=n("li",null,[n("p",null,[n("code",null,"__proto__"),s(" 原先是 JS 非标准属性，但是 es6 规范中开始标准化，"),n("code",null,"[[Prototype]]"),s(" 和 "),n("code",null,"__proto__"),s(" 意义相同")]),n("p",null,[n("img",{src:C,alt:"prototype"})])],-1),B=n("code",null,"prototype",-1),k=n("code",null,"__proto__",-1),x=o("",7),S=n("code",null,"__proto__",-1),O=n("li",null,"原型链就在于为对象成员查找机制提供一个方向，或者说一条路线",-1),N=o("",2),I=n("code",null,".prototype",-1),V=o("",6),M=o("",18),z=o("",11),H=o("",13),J=o("",6),L=o("",4),R=n("li",null,[n("code",null,"try...catch"),s(" 用于捕获错误信息")],-1),W=n("li",null,[s("将预估可能发生错误的代码写在 "),n("code",null,"try"),s(" 代码段中")],-1),U=n("li",null,[s("如果 "),n("code",null,"try"),s(" 代码段中出现错误后，会执行 "),n("code",null,"catch"),s(" 代码段，并截获到错误信息")],-1),$=n("code",null,"finally",-1),X=o("",3),Y=o("",4),Q=o("",12),G=n("li",null,"call 可以用来检测数据类型，apply 可以求数组最大值",-1),K=o("",9),Z=o("",3),ss=o("",10),ns=o("",14);function as(ls,ps,os,es,cs,rs){const a=t("font");return c(),r("div",null,[w,n("blockquote",null,[T,n("ul",null,[P,n("li",null,[n("p",null,[s("尽量"),l(a,{color:"red"},{default:p(()=>[s("不要修改")]),_:1}),s("这个属性，对性能影响非常严重的")])]),n("li",null,[n("p",null,[s("约定： "),B,s("："),l(a,{color:"red"},{default:p(()=>[s("原型对象")]),_:1}),s("， "),k,s("："),l(a,{color:"red"},{default:p(()=>[s("原型")]),_:1})])])])]),x,n("ul",null,[n("li",null,[s("当访问一个对象成员（属性/方法）时，首先查找这个"),l(a,{color:"red"},{default:p(()=>[s("对象自身")]),_:1}),s("有没有该成员（属性/方法）")]),n("li",null,[s("如果没有就查找它的原型对象（也就是 "),S,s(" 指向的 "),l(a,{color:"red"},{default:p(()=>[s("prototype 原型对象")]),_:1}),s("）")]),n("li",null,[s("如果还没有就查找原型对象的原型对象（"),l(a,{color:"red"},{default:p(()=>[s("Object 的原型对象")]),_:1}),s("）")]),n("li",null,[s("依此类推一直找到 Object 为止（"),l(a,{color:"red"},{default:p(()=>[s("null")]),_:1}),s("）")]),O]),N,n("p",null,[s("用来"),l(a,{color:"red"},{default:p(()=>[s("检测构造函数的原型对象 "),I]),_:1}),s(" 是否存在于"),l(a,{color:"red"},{default:p(()=>[s("实例对象")]),_:1}),s("的原型链上")]),V,n("p",null,[s("JavaScript 中大多是借助"),l(a,{color:"red"},{default:p(()=>[s("原型对象实现继承")]),_:1}),s("的特性")]),M,n("p",null,[s("浅拷贝：把对象拷贝给一个"),l(a,{color:"red"},{default:p(()=>[s("新的")]),_:1}),s("对象，开发中我们经常需要"),l(a,{color:"red"},{default:p(()=>[s("复制")]),_:1}),s("一个对象")]),n("p",null,[s("如果"),l(a,{color:"red"},{default:p(()=>[s("直接赋值")]),_:1}),s("，则复制的是"),l(a,{color:"red"},{default:p(()=>[s("地址")]),_:1}),s("，修改任何一个对象，另一个对象都会变化")]),z,n("p",null,[s("深拷贝："),l(a,{color:"red"},{default:p(()=>[s("拷贝多层")]),_:1}),s("，不再拷贝地址")]),H,n("p",null,[s("递归：所谓递归就是一种"),l(a,{color:"red"},{default:p(()=>[s("函数调用自身")]),_:1}),s("的操作")]),n("ul",null,[n("li",null,[n("p",null,[s("简单理解：函数内部"),l(a,{color:"red"},{default:p(()=>[s("自己调用自己")]),_:1}),s("，就是递归，这个函数就是递归函数")])]),n("li",null,[n("p",null,[s("递归函数的作用和"),l(a,{color:"red"},{default:p(()=>[s("循环")]),_:1}),s("效果类似")])]),n("li",null,[n("p",null,[s("由于递归很容易发生“栈溢出”错误（stackoverflow），所以记得添加"),l(a,{color:"red"},{default:p(()=>[s("退出条件 return")]),_:1})])])]),J,n("p",null,[s("异常处理是指预估代码执行过程中"),l(a,{color:"red"},{default:p(()=>[s("可能发生的错误")]),_:1}),s("，然后最大程度的避免错误的发生导致整个程序无法继续运行")]),L,n("ul",null,[R,W,U,n("li",null,[$,s(" 不管是否有错误，"),l(a,{color:"red"},{default:p(()=>[s("都会执行")]),_:1})])]),X,n("p",null,[s("debugger 语句调用"),l(a,{color:"red"},{default:p(()=>[s("调试功能")]),_:1}),s("，例如设置断点")]),Y,n("p",null,[s("JavaScript 中允许"),l(a,{color:"red"},{default:p(()=>[s("指定（改变）函数中 this 的指向")]),_:1}),s("，有 3 个方法可以动态指定普通函数中 this 的指向")]),Q,n("ul",null,[n("li",null,[s("都是"),l(a,{color:"red"},{default:p(()=>[s("调用函数")]),_:1}),s("，都能"),l(a,{color:"red"},{default:p(()=>[s("改变 this 指向")]),_:1})]),n("li",null,[s("参数不一样，call 是"),l(a,{color:"red"},{default:p(()=>[s("传递参数列表")]),_:1}),s("，apply 传递的必须是"),l(a,{color:"red"},{default:p(()=>[s("数组")]),_:1})]),G]),K,n("p",null,[s("this的取值不取决于函数的定义，而是取决于怎么"),l(a,{color:"red"},{default:p(()=>[s("调用")]),_:1}),s("的（this 指向调用者）")]),n("ul",null,[n("li",null,[l(a,{color:"red"},{default:p(()=>[s("全局")]),_:1}),s("内调用： fn() 指向 window")]),n("li",null,[l(a,{color:"red"},{default:p(()=>[s("对象内的方法")]),_:1}),s("调用：obj.fn() 指向调用对象")]),n("li",null,[l(a,{color:"red"},{default:p(()=>[s("构造函数")]),_:1}),s("调用：new Person() 指向实例对象")]),n("li",null,[l(a,{color:"red"},{default:p(()=>[s("事件处理函数")]),_:1}),s("中调用：指向当前触发事件的 DOM 元素")]),n("li",null,[l(a,{color:"red"},{default:p(()=>[s("特殊调用")]),_:1}),s("，比如 call、apply、bind 可以改变 this 指向，fun.call(obj) 指向 obj")])]),Z,n("p",null,[s("防抖: 单位时间内，频繁触发事件，"),l(a,{color:"red"},{default:p(()=>[s("只执行最后一次")]),_:1})]),ss,n("p",null,[s("节流：单位时间内，频繁触发事件，"),l(a,{color:"red"},{default:p(()=>[s("只执行一次")]),_:1})]),ns])}const Ds=e(q,[["render",as]]);export{ys as __pageData,Ds as default};
