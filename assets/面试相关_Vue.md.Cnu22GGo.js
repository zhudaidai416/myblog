import{_ as e,c as t,o,a3 as a}from"./chunks/framework.CHMinc71.js";const q=JSON.parse('{"title":"四、Vue2","description":"","frontmatter":{},"headers":[],"relativePath":"面试相关/Vue.md","filePath":"面试相关/Vue.md","lastUpdated":1684262502000}'),l={name:"面试相关/Vue.md"},i=a(`<h1 id="四、vue2" tabindex="-1">四、Vue2 <a class="header-anchor" href="#四、vue2" aria-label="Permalink to &quot;四、Vue2&quot;">​</a></h1><h2 id="_1、vue-的基本原理" tabindex="-1">1、Vue 的基本原理 <a class="header-anchor" href="#_1、vue-的基本原理" aria-label="Permalink to &quot;1、Vue 的基本原理&quot;">​</a></h2><blockquote><p>当一个 Vue 实例创建时，Vue 会遍历 data 中的属性，用 Object.defineProperty 将它们转为 getter/setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而使它关联的组件得以更新</p></blockquote><p><img src="https://pic1.zhimg.com/80/v2-ba09f483045c04d349ddeb45203142f0_720w.webp" alt="img"></p><h2 id="_2、响应式原理" tabindex="-1">2、响应式原理 <a class="header-anchor" href="#_2、响应式原理" aria-label="Permalink to &quot;2、响应式原理&quot;">​</a></h2><h3 id="数据劫持" tabindex="-1">数据劫持 <a class="header-anchor" href="#数据劫持" aria-label="Permalink to &quot;数据劫持&quot;">​</a></h3><blockquote><p>利用 Object.defineProperty 劫持对象的访问器，在属性发生变化时我们可以获取变化，从而进行下一步操作</p></blockquote><h3 id="发布者模式和订阅者模式" tabindex="-1">发布者模式和订阅者模式 <a class="header-anchor" href="#发布者模式和订阅者模式" aria-label="Permalink to &quot;发布者模式和订阅者模式&quot;">​</a></h3><blockquote><p>在软件架构中，发布订阅是一种消息范式，发布者不会将消息直接发送给订阅者，而是将发布的消息分为不同的类别，无需了解哪些订阅者是否存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者是否存在 <strong>发布者和订阅者都不知道对方的存在，发布者只需发送消息到订阅器里，订阅者只管接收自己订阅的内容</strong></p></blockquote><h3 id="响应式原理" tabindex="-1">响应式原理 <a class="header-anchor" href="#响应式原理" aria-label="Permalink to &quot;响应式原理&quot;">​</a></h3><blockquote><p>vue 的响应式原理就是<strong>采用数据劫持结合发布者-订阅者模式</strong>的方式，通过 Object.defineProperty()来劫持各个属性的 getter 和 setter，在数据变动时发布消息给订阅者，触发相应的监听回调。只要分为以下几个步骤：</p></blockquote><ol><li>需要给<strong>Observe</strong>（<em>被劫持的数据对象</em>）的数据对象进行递归遍历，包括子属性对象的属性，都加上 getter、setter 这样的属性。修改这个对象的某个属性，就会触发 setter，那么就能监听到数据的变化</li><li><strong>Compile</strong>（<em>Vue 的编译器</em>）解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加侦听数据的订阅者，当数据发生变化时会收到通知，更新视图</li><li><strong>Watcher</strong>（<em>订阅者</em>）是<strong>Observe</strong>和<strong>Compile</strong>之间的桥梁，主要做的事情有：</li><li>在自身实例化时<strong>Dep</strong>（用于收集订阅者的订阅器）里添加自己</li><li>自身必须拥有一个**update()**方法</li><li>待属性变动<strong>dep.notice()</strong> 通知时，能调用自身的<strong>update()</strong> 方法，并触发<strong>Compile</strong>中绑定的回调，则功成身退</li><li>MVVM 作为数据绑定的入口，整合<strong>Observer</strong>、<strong>Compile</strong>和<strong>Watcher</strong>三者，通过<strong>Observer</strong>来监听自己的<strong>model</strong>数据变化，通过<strong>Compile</strong>来解析编译模板指令，最终利用<strong>Watcher</strong>搭起<strong>Observer</strong>和<strong>Compile</strong>之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据 model 变更的双向绑定效果</li></ol><p><img src="https://pic4.zhimg.com/v2-9b0f214850c3e22e1ac23310acf49a97_r.jpg" alt="img"></p><h3 id="object-defineproperty-obj-prop-descriptor" tabindex="-1">Object.defineProperty(obj, prop, descriptor) <a class="header-anchor" href="#object-defineproperty-obj-prop-descriptor" aria-label="Permalink to &quot;Object.defineProperty(obj, prop, descriptor)&quot;">​</a></h3><ul><li>obj - 要定义的对象</li><li>prop - 要定义或修改的属性名称或 Symbol</li><li>descriptor - 要定义或修改的属性的描述符（配置对象）</li><li><strong>get</strong> 属性的 getter 函数，如果没有 getter，则为 <code>undefined</code>。当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 <code>this</code> 对象（由于继承关系，这里的<code>this</code>并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值</li><li>**默认为 [<code>undefined</code>]**<strong>set</strong> 属性的 setter 函数，如果没有 setter，则为 <code>undefined</code>。当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 <code>this</code> 对象。 **默认为 [<code>undefined</code>]**</li></ul><p><strong>缺点</strong>：在对一些属性进行操作时，使用这种方法无法拦截，比如<strong>通过下标方式修改数组</strong>数据或者<strong>给对象新增属性</strong>，这都不能触发组件的重新渲染，因为 Object.defineProperty() 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 <strong>Vue 内部通过重写函数的方式</strong>解决了这个问题</p><ul><li>返回值：被传递给函数的对象 obj</li></ul><h2 id="_3、mvvm" tabindex="-1">3、MVVM <a class="header-anchor" href="#_3、mvvm" aria-label="Permalink to &quot;3、MVVM&quot;">​</a></h2><blockquote><p>MVVM（Model-View-ViewModel）模式是一种基于前端开发的架构模式，其核心是提供对 View 和 Model 的双向数据绑定，即当 View 或 Model 其中任意一个发生变化时，都会通过 ViewModel 引起另外一个的改变。</p></blockquote><p><img src="https://pic2.zhimg.com/v2-15cc7cd5528914be10453b194fc6b499_r.jpg" alt="img"></p><ul><li>MVVM 的优点</li></ul><ol><li>双向绑定。数据层和视图层中任何一层发生变化，都会通过 ViewModel 使另一层变化，时刻保持数据和视图的一致性；</li><li>通过数据驱动视图更新，不再手动操作 DOM 元素，提高性能；</li></ol><ul><li>MVVM 的缺点</li></ul><ol><li>由于双向绑定的技术，产生 bug 后无法确定问题出现在数据层还是视图层；</li><li>数据层过大会占用更多的内存资源，影响性能；</li></ol><h2 id="_4、常用指令" tabindex="-1">4、常用指令 <a class="header-anchor" href="#_4、常用指令" aria-label="Permalink to &quot;4、常用指令&quot;">​</a></h2><table tabindex="0"><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>v-on</td><td>缩写为@，绑定事件</td></tr><tr><td>v-bind</td><td>简写为:，动态绑定</td></tr><tr><td>v-slot</td><td>简写为#，组件插槽</td></tr><tr><td>v-for</td><td>循环对象或数组元素，同时生成 DOM</td></tr><tr><td>v-show</td><td>显示内容与否</td></tr><tr><td>v-if</td><td>显示与隐藏，决定当前 DOM 元素是否渲染</td></tr><tr><td>v-else</td><td>必须和 v-if 连用 不能单独使用 否则报错</td></tr><tr><td>v-text</td><td>解析文本</td></tr><tr><td>v-html</td><td>解析 html 标签</td></tr></tbody></table><h2 id="_5、动态绑定-class-与-style" tabindex="-1">5、动态绑定 class 与 style <a class="header-anchor" href="#_5、动态绑定-class-与-style" aria-label="Permalink to &quot;5、动态绑定 class 与 style&quot;">​</a></h2><table tabindex="0"><thead><tr><th></th><th>class</th><th>style</th></tr></thead><tbody><tr><td>绑定对象</td><td>:class=&quot;{ className: isActive }&quot; 或 :class=&quot;classNameObject&quot;</td><td>:style=&quot;{color: &#39;#ffffff&#39;}&quot; 或 :style=&quot;styleObject&quot;</td></tr><tr><td>绑定数组</td><td>:class=&quot;[&#39;active&#39;, &#39;is-success&#39;, { &#39;is-disabled&#39;: isDisabled }]&quot;</td><td>:style=&quot;[styleObject1, styleObject2, styleObject3, ...]&quot;</td></tr></tbody></table><h2 id="_6、常见修饰符" tabindex="-1">6、常见修饰符 <a class="header-anchor" href="#_6、常见修饰符" aria-label="Permalink to &quot;6、常见修饰符&quot;">​</a></h2><h3 id="v-on" tabindex="-1">v-on <a class="header-anchor" href="#v-on" aria-label="Permalink to &quot;v-on&quot;">​</a></h3><table tabindex="0"><thead><tr><th>修饰符</th><th>作用</th></tr></thead><tbody><tr><td>.stop</td><td>event.stopPropagation()，阻止单击事件继续传播（阻止默认事件）</td></tr><tr><td>.prevent</td><td>event.preventDefault()，提交事件不再重载页面（阻止默认行为）</td></tr><tr><td>.native</td><td>监听组件根元素的原生事件</td></tr><tr><td>.once</td><td>点击事件将只会触发一次</td></tr></tbody></table><h3 id="v-model" tabindex="-1">v-model <a class="header-anchor" href="#v-model" aria-label="Permalink to &quot;v-model&quot;">​</a></h3><table tabindex="0"><thead><tr><th>修饰符</th><th>作用</th></tr></thead><tbody><tr><td>.lazy</td><td>取代 input 监听 change 事件</td></tr><tr><td>.number</td><td>输入值转为数值类型</td></tr><tr><td>.trim</td><td>输入首尾空格过滤</td></tr></tbody></table><h2 id="_7、v-if-与-v-show-的区别" tabindex="-1">7、v-if 与 v-show 的区别 <a class="header-anchor" href="#_7、v-if-与-v-show-的区别" aria-label="Permalink to &quot;7、v-if 与 v-show 的区别&quot;">​</a></h2><h3 id="原理" tabindex="-1">原理 <a class="header-anchor" href="#原理" aria-label="Permalink to &quot;原理&quot;">​</a></h3><ul><li>v-if 会调用 addIfCondition 方法根据条件渲染，为 false 时在生成 vnode 的时候会忽略对应节点，render 的时候就不会渲染</li><li>添加 v-show 指令的元素一定会渲染，只是通过修改 display 属性的值来决定是否显示</li></ul><h3 id="切换" tabindex="-1">切换 <a class="header-anchor" href="#切换" aria-label="Permalink to &quot;切换&quot;">​</a></h3><ul><li>v-if 切换时，DOM 元素会重复生成和销毁，会执行生命周期钩子</li><li>v-show 切换时不会执行生命周期钩子</li></ul><h3 id="应用场景" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景" aria-label="Permalink to &quot;应用场景&quot;">​</a></h3><p>需要频繁切换 DOM 时，使用 v-show；反之则使用 v-if</p><h2 id="_8、为什么避免-v-for-和-v-if-在一起使用" tabindex="-1">8、为什么避免 v-for 和 v-if 在一起使用? <a class="header-anchor" href="#_8、为什么避免-v-for-和-v-if-在一起使用" aria-label="Permalink to &quot;8、为什么避免 v-for 和 v-if 在一起使用?&quot;">​</a></h2><blockquote><p>Vue 处理指令时，v-for 比 v-if 具有更高的***优先级***，存在性能问题。 如果你有 5 个元素被 v-for 循环,，v-if 也会分别执行 5 次</p></blockquote><h2 id="_9、v-for-循环为什么一定要绑定-key" tabindex="-1">9、v-for 循环为什么一定要绑定 key <a class="header-anchor" href="#_9、v-for-循环为什么一定要绑定-key" aria-label="Permalink to &quot;9、v-for 循环为什么一定要绑定 key&quot;">​</a></h2><blockquote><p>提升 vue 渲染性能</p></blockquote><ul><li>key 的作用主要是为了更高效的更新虚拟 DOM，因为它可以非常精确的找到相同节点，因此 patch 过程会非常高效</li><li>Vue 在 patch 过程中会判断两个节点是不是相同节点时，key 是一个必要条件。比如渲染列表时，如果不写 key，Vue 在比较的时候，就可能会导致频繁更新元素，使整个 patch 过程比较低效，影响性能</li><li>应该避免使用数组下标作为 key，因为 key 值不是唯一的话可能会导致上面图中表示的 bug，使 Vue 无法区分它他，还有比如在使用相同标签元素过渡切换的时候，就会导致只替换其内部属性而不会触发过渡效果</li><li>Vue 判断两个节点是否相同时主要判断两者的元素类型和 key 等，如果不设置 key，就可能永远认为这两个是相同节点，只能去做更新操作，就造成大量不必要的 DOM 更新操作，明显是不可取的</li></ul><h2 id="_10、为什么不建议用-index-索引作为-key" tabindex="-1">10、为什么不建议用 index 索引作为 key? <a class="header-anchor" href="#_10、为什么不建议用-index-索引作为-key" aria-label="Permalink to &quot;10、为什么不建议用 index 索引作为 key?&quot;">​</a></h2><blockquote><p>使用 index 作为 key 和没写基本上没区别，因为不管数组的顺序怎么颠倒，index 都是 0, 1, 2...这样排列，导致 Vue 会复用错误的旧子节点，做很多无意义的额外工作</p></blockquote><h2 id="_11、v-model" tabindex="-1">11、v-model <a class="header-anchor" href="#_11、v-model" aria-label="Permalink to &quot;11、v-model&quot;">​</a></h2><p>v-model 用于实现视图层与数据层的双向绑定，数据层变化时可以驱动视图层更新，当视图层变化时会改变数据。v-model 本质上是一个语法糖，默认情况下相当于<code>:value</code>和<code>@input</code>的结合。</p><p>v-model 通常使用在表单项上，但也能使用在自定义组件上，表示对某个值的输入和输出控制。使用 v-model 可以减少大量繁琐的事件处理代码，提高开发效率。</p><h2 id="_12、v-model-与-sync-的对比" tabindex="-1">12、v-model 与.sync 的对比 <a class="header-anchor" href="#_12、v-model-与-sync-的对比" aria-label="Permalink to &quot;12、v-model 与.sync 的对比&quot;">​</a></h2><p>共同点：都是语法糖，都可以实现父子组件中数据的双向通信</p><p>不同点：</p><table tabindex="0"><thead><tr><th>v-model</th><th>.sync</th></tr></thead><tbody><tr><td>父组件中使用 v-model 传递数据时，子组件通过@input 触发事件</td><td>父组件中传递数据时，子组件通过@update:xxx 触发事件</td></tr><tr><td>一个组件只能绑定一个 v-model vue2</td><td>一个组件可以多个属性用.sync 修饰符，可以同时&quot;双向绑定多个“prop”</td></tr><tr><td>v-model 针对更多的是最终操作结果，是双向绑定的结果，是 value，是一种 change 操作</td><td>.sync 针对更多的是各种各样的状态，是状态的互相传递，是 status，是一种 update 操作</td></tr></tbody></table><h2 id="_13、computed-与-watch-的区别" tabindex="-1">13、computed 与 watch 的区别 <a class="header-anchor" href="#_13、computed-与-watch-的区别" aria-label="Permalink to &quot;13、computed 与 watch 的区别&quot;">​</a></h2><blockquote><p>computed</p></blockquote><ul><li><strong>支持缓存</strong>，只有依赖的数据发生了变化，才会重新计算</li><li>不支持异步，当 computed 中有异步操作时，无法监听数据的变化</li><li>computed 的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，即 data 中声明的数据或 props 传递的数据</li><li>如果一个属性是由其他属性计算而来，这个属性依赖其它属性，一般会使用 computed</li><li>如果 computed 属性的属性值是函数，那么<strong>默认使用 get 方法</strong>，函数的返回值就是属性的属性值；在 computed 中，属性有一个 get 方法和一个 set 方法，当数据发生变化时，会调用 set 方法</li></ul><blockquote><p>watch</p></blockquote><ul><li><strong>不支持缓存</strong>，数据变化会执行相应操作</li><li>支持异步监听</li><li>监听的函数接收两个参数，第一个参数为更新后的值，第二个参数为更新前的值‘</li><li>当一个属性发生变化时，就需要执行相应的操作</li><li>监听数据必须是 data 中声明的或者父组件传递过来的 props 中的数据，当发生变化时，会触发其他操作，函数有两个的参数：</li><li><strong>immediate</strong>：默认为 false，为 true 时组件加载会立即触发</li><li><strong>deep</strong>：默认为 false，为 true 时开启深度监听。需要注意的是，deep 无法监听到数组和对象内部的变化</li></ul><p>当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用 watch</p><blockquote><p>总结 <code>computed</code> 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。 <code>watch</code> 侦听器 : 更多的是<strong>观察</strong>的作用，<strong>无缓存性</strong>，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。</p></blockquote><h2 id="_14、组件通信" tabindex="-1">14、组件通信 <a class="header-anchor" href="#_14、组件通信" aria-label="Permalink to &quot;14、组件通信&quot;">​</a></h2><blockquote><p>组件通信指的是组件通过某一种方式来传递信息以达到某个目的的过程。每个组件都是独立的，在开发中我们就是通过组件通信使各个组件的功能联动起来</p></blockquote><h3 id="props-emit" tabindex="-1">props/$emit <a class="header-anchor" href="#props-emit" aria-label="Permalink to &quot;props/$emit&quot;">​</a></h3><blockquote><p>父组件通过 props 向子组件传递数据，子组件通过$emit 事件和父组件通信</p></blockquote><ul><li>props 只能是父组件向子组件传递数据，使得父子组件直接形成一个向下的单向数据流。子组件不能直接修改 props 数据，只能通知父组件来修改</li><li>$emit 绑定一个自定义事件，可以将参数传递给父组件；父组件中则通过<code>v-on</code>注册监听事件同时接收参数</li></ul><h3 id="provide-inject" tabindex="-1">provide/inject <a class="header-anchor" href="#provide-inject" aria-label="Permalink to &quot;provide/inject&quot;">​</a></h3><blockquote><p>这种方式是通过依赖注入的方式实现组件的（可跨级）通信。<em>依赖注入所提供的属性是<strong>非响应式</strong>的。</em></p></blockquote><ul><li>provide：用来发送数据或方法</li><li>inject：用来接收数据或方法</li></ul><h3 id="ref-refs" tabindex="-1">ref/$refs <a class="header-anchor" href="#ref-refs" aria-label="Permalink to &quot;ref/$refs&quot;">​</a></h3><blockquote><p>在父组件中通过 ref 可以获取子组件实例，通过实例来访问子组件的属性和方法</p></blockquote><h3 id="parent-children" tabindex="-1">$parent/$children <a class="header-anchor" href="#parent-children" aria-label="Permalink to &quot;$parent/$children&quot;">​</a></h3><ul><li>$parent可以获取上一级父组件实例，$root 来访问根组件的实例</li><li>$children 可以让组件访问所有子组件的实例，但是不能保证顺序，访问的数据也不是响应式的</li><li>在根组件#app 上拿$parent得到的是new Vue()的实例，在这实例上再拿$parent 得到的是 undefined，而在最底层的子组件拿$children 是个空数组</li><li>$children 的值是<strong>数组</strong>，而$parent 是个<strong>对象</strong></li></ul><h3 id="attrs-listeners" tabindex="-1">$attrs/$listeners <a class="header-anchor" href="#attrs-listeners" aria-label="Permalink to &quot;$attrs/$listeners&quot;">​</a></h3><blockquote><p>inheritAttrs：默认值为 true，继承所有的父组件属性（除 props 之外的所有属性），为 false 表示只继承 class 属性</p></blockquote><ul><li>$attrs：继承所有的父组件属性（除了 prop 传递的属性、class 和 style）</li><li>$listeners：该属性是一个对象，里面包含了作用在这个组件上的所有监听器，可以配合 <code>v-on=&quot;$listeners&quot;</code> 将所有的事件监听器指向这个组件的某个特定的子元素。（相当于子组件继承父组件的事件）</li></ul><h3 id="eventbus-事件总线" tabindex="-1">eventBus 事件总线 <a class="header-anchor" href="#eventbus-事件总线" aria-label="Permalink to &quot;eventBus 事件总线&quot;">​</a></h3><blockquote><p>eventBus 事件总线适用于父子组件、非父子组件等之间的通信。这种组件通信方式会造成后期维护困难。vue3 中移除了事件总线，取而代之的是插件，使用方式并无变化。</p></blockquote><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>子组件不能直接修改父组件传递的数据，这样做是维护父子组件之间形成的单向数据流。如果子组件随意更改父组件传递的数据，会导致数据流混乱，提高开发和维护成本</p><h2 id="_15、生命周期" tabindex="-1">15、生命周期 <a class="header-anchor" href="#_15、生命周期" aria-label="Permalink to &quot;15、生命周期&quot;">​</a></h2><blockquote><p>生命周期指的是 Vue 组件从创建到销毁经历的一系列的过程</p></blockquote><ul><li>创建前后</li><li>beforeCreate - 组件创建之前，无法获取 data 中的数据</li><li>created - 组件创建完成后，可以获取数据</li><li>渲染前后</li><li>beforeMount - 组件挂载到 DOM 之前</li><li>mounted - 组件挂载完毕，可以获取 DOM 节点</li><li>更新前后</li><li>beforeUpdate - 响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染</li><li>updated - 在由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM 已经更新，所以可以执行依赖于 DOM 的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用</li><li>销毁前后</li><li>beforeDestroy - 实例销毁之前调用。这一步，实例仍然完全可用，<code>this</code> 仍能获取到实例</li><li>destroyed - 实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁</li></ul><blockquote><p>父子组件的生命周期执行顺序</p></blockquote><ul><li>加载渲染过程</li><li>父 beforeCreate - 父 created - 父 beforeMount - 子 beforeCreate - 子 created - 子 beforeMount - 子 mounted - 父 mounted</li><li>更新过程</li><li>父 beforeUpdate - 子 beforeUpdate - 子 updated - 父 updated</li><li>销毁过程</li><li>父 beforeDestroy - 子 beforeDestroy - 子 destroyed - 父 destroyed</li></ul><blockquote><p>created 和 mounted 的区别</p></blockquote><ul><li>created：在模板渲染成 html 前调用，即通常初始化某些属性值，然后再渲染成视图</li><li>mounted：在模板渲染成 html 后调用，通常是初始化页面完成后，再对 html 的 dom 节点进行一些需要的操作</li></ul><blockquote><p>一般在哪个生命周期请求异步数据</p></blockquote><p>我们可以在钩子函数<code>created</code>、<code>beforeMount</code>、<code>mounted</code> 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值</p><p>推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p><ul><li>能更快获取到服务端数据，减少页面加载时间，用户体验更好</li><li>SSR 不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性</li></ul><h2 id="_16、keep-alive" tabindex="-1">16、keep-alive <a class="header-anchor" href="#_16、keep-alive" aria-label="Permalink to &quot;16、keep-alive&quot;">​</a></h2><blockquote><p>keep-alive 用于缓存组件。在进行动态组件切换的时候对组件内部数据进行缓存，而不是走销毁流程。keep-alive 是一个抽象组件，它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。 当组件在<code>&lt;keep-alive&gt;</code>内被切换，它的<code>activated</code>和 <code>deactivated</code>这两个生命周期钩子函数将会被对应执行</p></blockquote><p>包含的参数：</p><ul><li>include - 名称匹配的组件会被缓存 --&gt; include 的值为组件的 name</li><li>exclude - 任何名称匹配的组件都不会被缓存</li><li>max - 决定最多可以缓存多少组件</li></ul><table tabindex="0"><thead><tr><th>activated</th><th>deactivated</th></tr></thead><tbody><tr><td>在 keep-alive 组件激活时调用</td><td>在 keep-alive 组件停用时调用</td></tr><tr><td>该钩子函数在服务器端渲染期间不被调用</td><td>该钩子在服务器端渲染期间不被调用</td></tr></tbody></table><p>设置缓存后的钩子调用情况：</p><ul><li>第一次进入：beforeRouterEnter -&gt;created-&gt;…-&gt;activated-&gt;…-&gt;deactivated&gt; beforeRouteLeave</li><li>后续进入时：beforeRouterEnter -&gt;activated-&gt;deactivated&gt; beforeRouteLeave</li></ul><h2 id="_17、slot-插槽" tabindex="-1">17、slot 插槽 <a class="header-anchor" href="#_17、slot-插槽" aria-label="Permalink to &quot;17、slot 插槽&quot;">​</a></h2><blockquote><p>slot 是 Vue 的内容分发机制，组件内部的模板引擎使用 slot 元素作为承载分发内容的出口。插槽 slot 是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的</p></blockquote><ul><li>默认插槽</li></ul><blockquote><p>子组件用<code>&lt;slot&gt;</code>标签来确定渲染的位置，标签里面可以放<code>DOM</code>结构，当父组件使用的时候没有往插槽传入内容，标签内<code>DOM</code>结构就会显示在页面。父组件在使用的时候，直接在子组件的标签内写入内容即可</p></blockquote><ul><li>具名插槽</li></ul><blockquote><p>子组件用<code>name</code>属性来表示插槽的名字，不传为默认插槽。父组件中在使用时在默认插槽的基础上加上<code>slot</code>属性，值为子组件插槽<code>name</code>属性值</p></blockquote><ul><li>作用域插槽</li></ul><blockquote><p>子组件在作用域上绑定属性来将子组件的信息传给父组件使用，这些属性会被挂在父组件<code>v-slot</code>接受的对象上父组件中在使用时通过<code>v-slot:</code>（简写：#）获取子组件的信息，在内容中使用</p></blockquote><p>小结：</p><ol><li><code>v-slot</code>属性只能在<code>&lt;template&gt;</code>上使用，但在只有默认插槽时可以在组件标签上使用</li><li>默认插槽名为<code>default</code>，可以省略 default 直接写<code>v-slot</code>。缩写为<code>#</code>时不能不写参数，写成<code>#default</code></li><li>可以通过解构获取<code>v-slot={user}</code>，还可以重命名<code>v-slot=&quot;{user: newName}&quot;</code>和定义默认值<code>v-slot=&quot;{user = &#39;默认值&#39;}&quot;</code></li></ol><h2 id="_18、为什么-data-是一个函数而不是一个对象" tabindex="-1">18、为什么 data 是一个函数而不是一个对象 <a class="header-anchor" href="#_18、为什么-data-是一个函数而不是一个对象" aria-label="Permalink to &quot;18、为什么 data 是一个函数而不是一个对象&quot;">​</a></h2><blockquote><p>保证每个组件内数据的独立性，防止出现变量污染。对象为引用类型，当复用组件时，由于数据对象都指向同一个 data 对象，当在一个组件中修改 data 时，其他重用的组件中的 data 会同时被修改；而使用返回对象的函数，由于每次返回的都是一个新对象（Object 的实例），引用地址不同，则不会出现这个问题。</p></blockquote><h2 id="_19、vue-router" tabindex="-1">19、Vue-Router <a class="header-anchor" href="#_19、vue-router" aria-label="Permalink to &quot;19、Vue-Router&quot;">​</a></h2><h3 id="对前端路由的理解" tabindex="-1">对前端路由的理解 <a class="header-anchor" href="#对前端路由的理解" aria-label="Permalink to &quot;对前端路由的理解&quot;">​</a></h3><blockquote><p>前端路由的核心，就在于改变视图的同时不会向后端发出请求；而是加载路由对应的组件。Vue-Router 就是将组件映射到路由, 然后渲染出来的</p></blockquote><ul><li>拦截用户的刷新操作，避免服务端盲目响应、返回不符合预期的资源内容。把刷新这个动作完全放到前端逻辑里消化调</li><li>感知 URL 的变化，根据这些变化使用 js 生成不同的内容</li></ul><h3 id="什么是-vue-router-有哪些组件" tabindex="-1">什么是 Vue-Router，有哪些组件 <a class="header-anchor" href="#什么是-vue-router-有哪些组件" aria-label="Permalink to &quot;什么是 Vue-Router，有哪些组件&quot;">​</a></h3><blockquote><p>Vue-Router 是 Vue 官方的路由管理器。它和 Vue.js 的核心深度集成，路径和组件的映射关系使得构建 SPA（Single Page Application，单页面应用）变得易如反掌</p></blockquote><ul><li>router-link - 实质上最终会渲染成 a 链接</li><li>router-view - 子级路由显示</li><li>keep-alive - 包裹组件缓存</li></ul><h3 id="route和-router" tabindex="-1">$route和$router <a class="header-anchor" href="#route和-router" aria-label="Permalink to &quot;$route和$router&quot;">​</a></h3><ul><li>$route 是路由信息对象，包含了 path、params、hash、query、fullPath、matched、name 等路由信息参数</li><li>$router 是路由的实例对象，包含了路由的跳转方法、钩子函数等内容</li></ul><h3 id="路由开发的优缺点" tabindex="-1">路由开发的优缺点 <a class="header-anchor" href="#路由开发的优缺点" aria-label="Permalink to &quot;路由开发的优缺点&quot;">​</a></h3><p>优点：</p><ul><li>整体不刷新页面，用户体验更好</li><li>数据传递简单，开发效率高</li></ul><p>缺点：</p><ul><li>学习成本高</li><li>首次加载缓慢，不利于 seo</li></ul><h3 id="使用方式" tabindex="-1">使用方式 <a class="header-anchor" href="#使用方式" aria-label="Permalink to &quot;使用方式&quot;">​</a></h3><ol><li>新建 index.js 路由入口文件</li><li>创建路由规则</li><li>创建路由对象</li><li>将路由对象挂载到 Vue.use()中</li><li>将路由对象挂载到 Vue 实例上</li></ol><h3 id="hash-模式" tabindex="-1">Hash 模式 <a class="header-anchor" href="#hash-模式" aria-label="Permalink to &quot;Hash 模式&quot;">​</a></h3><blockquote><p>基于浏览器的 hashchange 事件，当 url 发生变化时，通过 <code>window.location.hash</code> 获取地址上的 hash 值，并通过 Router 类，配置 routes 对象设置与 hash 值对应的组件内容</p></blockquote><p>优点：</p><ul><li>hash 值会出现在 url 中，但是不会被包含在 http 请求中，因此 hash 值改变不会重新加载页面</li><li>hash 改变会触发 hashchange 事件，能控制浏览器的前进后退</li><li>兼容性好</li></ul><p>缺点：</p><ul><li>地址中携带#，不美观</li><li>只可修改#后面的部分，因此只能设置与当前 URL 同文档的 URL</li><li>hash 有体积限制，故只可以添加短字符串</li><li>设置的新值必须与原来不同才会触发 hashchange 事件，并将记录添加到栈中</li><li>每次 URL 的改变不属于一次 http 请求，所以不利于 seo 优化</li></ul><h3 id="history-模式" tabindex="-1">History 模式 <a class="header-anchor" href="#history-模式" aria-label="Permalink to &quot;History 模式&quot;">​</a></h3><blockquote><p>基于 H5 新增的 pushState()和 replaceState()两个 api，以及浏览器的 popstate 事件，地址变化时，通过 <code>window.location.pathname</code> 找到对应的组件，并通过构造 Router 类，配置 routes 对象设置 pathname 值与对应的组件内容</p></blockquote><p>优点：</p><ul><li>没有#，相对美观</li><li>pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL</li><li>pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中</li><li>pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中</li><li>pushState() 可额外设置 title 属性供后续使用</li><li>浏览器的进后退能触发浏览器的 popstate 事件，获取 window.location.pathname 来控制页面的变化</li></ul><p>缺点：</p><ul><li>URL 的改变属于 http 请求，借助 history.pushState 实现页面的无刷新跳转，因此会重新请求服务器。所以<strong>前端的 URL 必须和实际向后端发起请求的 URL 一致</strong>。如果用户输入的 URL 回车或者浏览器刷新或者分享出去某个页面路径，用户点击后，URL 与后端配置的页面请求 URL 不一致，则匹配不到任何静态资源，就会返回 404 页面。所以需要后台配置支持，覆盖所有情况的候选资源，如果 URL 匹配不到任何静态资源，则应该返回 app 依赖的页面或者应用首页</li><li><strong>兼容性差</strong>，特定浏览器支持</li></ul><h3 id="路由-hash-模式和-history-模式的区别" tabindex="-1"><strong>路由 hash 模式和 history 模式的区别</strong> <a class="header-anchor" href="#路由-hash-模式和-history-模式的区别" aria-label="Permalink to &quot;**路由 hash 模式和 history 模式的区别**&quot;">​</a></h3><blockquote><p><code>hash</code> 模式是一种把前端路由的路径用 <code>#</code> 拼接在真实 <code>url</code> 后面的模式。当 <code>#</code> 后面的路径发生变化时，浏览器并不会重新发起请求，而是会触发 <code>onhashchange</code> 事件。 hash 模式的特点：</p></blockquote><ul><li><code>hash</code>变化会触发网页跳转，即浏览器的前进和后退</li><li><code>hash</code> 可以改变 <code>url</code> ，但是不会触发页面重新加载（hash 的改变是记录在 <code>window.history</code> 中），即不会刷新页面。也就是说，所有页面的跳转都是在客户端进行操作。因此，这并不算是一次 <code>http</code> 请求，所以这种模式不利于 <code>SEO</code> 优化。<code>hash</code> 只能修改 <code>#</code> 后面的部分，所以只能跳转到与当前 <code>url</code> 同文档的 <code>url</code></li><li><code>hash</code> 通过触发 <code>hashchange</code> 事件，来监听 <code>hash</code> 的改变，借此实现无刷新跳转的功能</li><li><code>hash</code> 永远不会提交到 <code>server</code> 端（可以理解为只在前端自生自灭）</li></ul><p><code>history API</code> 是 <code>H5</code> 提供的新特性，允许开发者<strong>直接更改前端路由</strong>，即更新浏览器 <code>URL</code> 地址而<strong>不重新发起请求</strong></p><ul><li>新的 <code>url</code> 可以是与当前 <code>url</code> 同源的任意 <code>url</code> ，也可以是与当前 <code>url</code> 一样的地址，但是这样会导致的一个问题是，会把<strong>重复的这一次操作</strong>记录到栈当中</li><li>通过 <code>history.state</code> ，添加任意类型的数据到记录中</li><li>可以额外设置 <code>title</code> 属性，以便后续使用</li><li>通过 <code>pushState</code> 、 <code>replaceState</code> 来实现无刷新跳转的功能，需要后端配合</li></ul><h3 id="history-模式下的-404-问题" tabindex="-1">history 模式下的 404 问题 <a class="header-anchor" href="#history-模式下的-404-问题" aria-label="Permalink to &quot;history 模式下的 404 问题&quot;">​</a></h3><ol><li>URL 的改变属于 http 请求，借助 history.pushState 实现页面的无刷新跳转，因此会重新请求服务器</li><li>所以前端的 URL 必须和实际向后端发起请求的 URL 一致</li></ol><h3 id="编程式导航" tabindex="-1">编程式导航 <a class="header-anchor" href="#编程式导航" aria-label="Permalink to &quot;编程式导航&quot;">​</a></h3><table tabindex="0"><thead><tr><th>方式</th><th>作用</th></tr></thead><tbody><tr><td>$router.push()</td><td>跳转到指定的 url，并在 history 中添加记录，点击回退返回到上一个页面</td></tr><tr><td>$router.replace()</td><td>跳转到指定的 url，但是 history 中不会添加记录，点击回退到上上个页面</td></tr><tr><td>$router.go(n)</td><td>向前或者后跳转 n 个页面，n 可以是正数也可以是负数</td></tr><tr><td>$router.back()</td><td>后退、回到上一页</td></tr><tr><td>$router.forward()</td><td>前进、回到下一页</td></tr></tbody></table><h3 id="路由传参的方式" tabindex="-1">路由传参的方式 <a class="header-anchor" href="#路由传参的方式" aria-label="Permalink to &quot;路由传参的方式&quot;">​</a></h3><ul><li>query 传参</li></ul><blockquote><p>query 传参需要使用 path 来引入，页面跳转后参数将会出现在 url 中；也可以直降将参数以?xxx=xx&amp;xxx=xx 的形式拼接在路由地址中</p></blockquote><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/example&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, query: { id: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } }); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 传递query参数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$route.query.id; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 获取query参数</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>以 query 的方式传参时，刷新页面不会导致参数丢失</strong></p><ul><li>params 传参</li></ul><blockquote><p>params 传参需要使用 name 来引入，页面跳转后参数不会出现在 url 中；在 4.1.4 版本开始，在未定义动态路由的情况下，将不能直接使用编程式导航传递 params 参数，目的是解决刷新页面参数丢失的问题</p></blockquote><p>传参的方式总结</p><ul><li>this.$router.push(path)</li><li>this.$router.push({path, query})</li><li>this.$router.push({name, params}) // 注意版本更新</li><li>this.$router.push({name, query})</li></ul>`,156),r=[i];function d(s,h,c,u,n,p){return o(),t("div",null,r)}const k=e(l,[["render",d]]);export{q as __pageData,k as default};
