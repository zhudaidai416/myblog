import{_ as h,D as k,c as t,j as i,a as s,I as n,w as l,a3 as p,aR as e,o as r,aS as E,aT as d,aU as g,aV as y,aW as c,aX as b,aY as F,aZ as o,a_ as u,a$ as m,b0 as C,b1 as A,b2 as D,b3 as B,b4 as _,b5 as f}from"./chunks/framework.CX7ZiWGr.js";const rs=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"前端基础/JS高级（下）.md","filePath":"前端基础/JS高级（下）.md","lastUpdated":1699899456000}'),v={name:"前端基础/JS高级（下）.md"},j=p("",48),q=i("p",null,"⚠️ 注：",-1),w=i("li",null,[i("p",null,[i("code",null,"__proto__"),s(" 原先是 JS 非标准属性，但是 es6 规范中开始标准化，"),i("code",null,"[[Prototype]]"),s(" 和 "),i("code",null,"__proto__"),s(" 意义相同")]),i("p",null,[i("img",{src:e,alt:"prototype"})])],-1),x=i("code",null,"prototype",-1),T=i("code",null,"__proto__",-1),P=p("",7),S=i("code",null,"__proto__",-1),O=i("li",null,"原型链就在于为对象成员查找机制提供一个方向，或者说一条路线",-1),N=p("",2),I=i("code",null,".prototype",-1),V=p("",6),M=p("",18),z=p("",11),H=p("",13),J=p("",6),R=p("",4),L=i("li",null,[i("code",null,"try...catch"),s(" 用于捕获错误信息")],-1),W=i("li",null,[s("将预估可能发生错误的代码写在 "),i("code",null,"try"),s(" 代码段中")],-1),U=i("li",null,[s("如果 "),i("code",null,"try"),s(" 代码段中出现错误后，会执行 "),i("code",null,"catch"),s(" 代码段，并截获到错误信息")],-1),$=i("code",null,"finally",-1),X=p("",3),Y=p("",4),Z=p("",12),G=i("li",null,"call 可以用来检测数据类型，apply 可以求数组最大值",-1),K=p("",9),Q=p("",3),ss=p("",10),is=p("",14);function as(ns,ls,ps,hs,ks,ts){const a=k("font");return r(),t("div",null,[j,i("blockquote",null,[q,i("ul",null,[w,i("li",null,[i("p",null,[s("尽量"),n(a,{color:"red"},{default:l(()=>[s("不要修改")]),_:1}),s("这个属性，对性能影响非常严重的")])]),i("li",null,[i("p",null,[s("约定： "),x,s("："),n(a,{color:"red"},{default:l(()=>[s("原型对象")]),_:1}),s("， "),T,s("："),n(a,{color:"red"},{default:l(()=>[s("原型")]),_:1})])])])]),P,i("ul",null,[i("li",null,[s("当访问一个对象成员（属性/方法）时，首先查找这个"),n(a,{color:"red"},{default:l(()=>[s("对象自身")]),_:1}),s("有没有该成员（属性/方法）")]),i("li",null,[s("如果没有就查找它的原型对象（也就是 "),S,s(" 指向的 "),n(a,{color:"red"},{default:l(()=>[s("prototype 原型对象")]),_:1}),s("）")]),i("li",null,[s("如果还没有就查找原型对象的原型对象（"),n(a,{color:"red"},{default:l(()=>[s("Object 的原型对象")]),_:1}),s("）")]),i("li",null,[s("依此类推一直找到 Object 为止（"),n(a,{color:"red"},{default:l(()=>[s("null")]),_:1}),s("）")]),O]),N,i("p",null,[s("用来"),n(a,{color:"red"},{default:l(()=>[s("检测构造函数的原型对象 "),I]),_:1}),s(" 是否存在于"),n(a,{color:"red"},{default:l(()=>[s("实例对象")]),_:1}),s("的原型链上")]),V,i("p",null,[s("JavaScript 中大多是借助"),n(a,{color:"red"},{default:l(()=>[s("原型对象实现继承")]),_:1}),s("的特性")]),M,i("p",null,[s("浅拷贝：把对象拷贝给一个"),n(a,{color:"red"},{default:l(()=>[s("新的")]),_:1}),s("对象，开发中我们经常需要"),n(a,{color:"red"},{default:l(()=>[s("复制")]),_:1}),s("一个对象")]),i("p",null,[s("如果"),n(a,{color:"red"},{default:l(()=>[s("直接赋值")]),_:1}),s("，则复制的是"),n(a,{color:"red"},{default:l(()=>[s("地址")]),_:1}),s("，修改任何一个对象，另一个对象都会变化")]),z,i("p",null,[s("深拷贝："),n(a,{color:"red"},{default:l(()=>[s("拷贝多层")]),_:1}),s("，不再拷贝地址")]),H,i("p",null,[s("递归：所谓递归就是一种"),n(a,{color:"red"},{default:l(()=>[s("函数调用自身")]),_:1}),s("的操作")]),i("ul",null,[i("li",null,[i("p",null,[s("简单理解：函数内部"),n(a,{color:"red"},{default:l(()=>[s("自己调用自己")]),_:1}),s("，就是递归，这个函数就是递归函数")])]),i("li",null,[i("p",null,[s("递归函数的作用和"),n(a,{color:"red"},{default:l(()=>[s("循环")]),_:1}),s("效果类似")])]),i("li",null,[i("p",null,[s("由于递归很容易发生“栈溢出”错误（stackoverflow），所以记得添加"),n(a,{color:"red"},{default:l(()=>[s("退出条件 return")]),_:1})])])]),J,i("p",null,[s("异常处理是指预估代码执行过程中"),n(a,{color:"red"},{default:l(()=>[s("可能发生的错误")]),_:1}),s("，然后最大程度的避免错误的发生导致整个程序无法继续运行")]),R,i("ul",null,[L,W,U,i("li",null,[$,s(" 不管是否有错误，"),n(a,{color:"red"},{default:l(()=>[s("都会执行")]),_:1})])]),X,i("p",null,[s("debugger 语句调用"),n(a,{color:"red"},{default:l(()=>[s("调试功能")]),_:1}),s("，例如设置断点")]),Y,i("p",null,[s("JavaScript 中允许"),n(a,{color:"red"},{default:l(()=>[s("指定（改变）函数中 this 的指向")]),_:1}),s("，有 3 个方法可以动态指定普通函数中 this 的指向")]),Z,i("ul",null,[i("li",null,[s("都是"),n(a,{color:"red"},{default:l(()=>[s("调用函数")]),_:1}),s("，都能"),n(a,{color:"red"},{default:l(()=>[s("改变 this 指向")]),_:1})]),i("li",null,[s("参数不一样，call 是"),n(a,{color:"red"},{default:l(()=>[s("传递参数列表")]),_:1}),s("，apply 传递的必须是"),n(a,{color:"red"},{default:l(()=>[s("数组")]),_:1})]),G]),K,i("p",null,[s("this的取值不取决于函数的定义，而是取决于怎么"),n(a,{color:"red"},{default:l(()=>[s("调用")]),_:1}),s("的（this 指向调用者）")]),i("ul",null,[i("li",null,[n(a,{color:"red"},{default:l(()=>[s("全局")]),_:1}),s("内调用： fn() 指向 window")]),i("li",null,[n(a,{color:"red"},{default:l(()=>[s("对象内的方法")]),_:1}),s("调用：obj.fn() 指向调用对象")]),i("li",null,[n(a,{color:"red"},{default:l(()=>[s("构造函数")]),_:1}),s("调用：new Person() 指向实例对象")]),i("li",null,[n(a,{color:"red"},{default:l(()=>[s("事件处理函数")]),_:1}),s("中调用：指向当前触发事件的 DOM 元素")]),i("li",null,[n(a,{color:"red"},{default:l(()=>[s("特殊调用")]),_:1}),s("，比如 call、apply、bind 可以改变 this 指向，fun.call(obj) 指向 obj")])]),Q,i("p",null,[s("防抖: 单位时间内，频繁触发事件，"),n(a,{color:"red"},{default:l(()=>[s("只执行最后一次")]),_:1})]),ss,i("p",null,[s("节流：单位时间内，频繁触发事件，"),n(a,{color:"red"},{default:l(()=>[s("只执行一次")]),_:1})]),is])}const Es=h(v,[["render",as]]);export{rs as __pageData,Es as default};
